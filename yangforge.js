// Generated by CoffeeScript 1.9.3
(function() {
  var YangCompiler, YangForge,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  YangCompiler = require('yang-compiler');

  YangForge = (function(superClass) {
    var assert, fs, path;

    extend(YangForge, superClass);

    YangForge.set({
      synth: 'forge',
      extensions: {},
      actions: {}
    });

    YangForge.extension = function(name, func) {
      return this.set("extensions." + name + ".resolver", func);
    };

    YangForge.action = function(name, func) {
      return this.set("actions." + name, func);
    };

    assert = require('assert');

    path = require('path');

    fs = require('fs');

    function YangForge(input, hooks) {
      var Forgery, config, err, i, len, pkgdir, schema, schemas;
      if (input == null) {
        input = {};
      }
      if (hooks == null) {
        hooks = {};
      }
      if (this.constructor === Object) {
        assert(input instanceof (require('module')), "must pass in 'module' when forging a new module definition, i.e. forge(module)");
        if (module.loaded !== true) {
          module.exports = YangForge;
        }
        console.log("INFO: [forge] processing " + input.id + "...");
        try {
          pkgdir = path.dirname(input.filename);
          config = require(path.resolve(pkgdir, './package.json'));
          schemas = (config.schema instanceof Array ? config.schema : [config.schema]).filter(function(e) {
            return (e != null) && !!e;
          }).map(function(schema) {
            return fs.readFileSync(path.resolve(pkgdir, schema), 'utf-8');
          });
        } catch (_error) {
          err = _error;
          console.log("Unable to discover YANG schema for the target module, missing 'schema' in package.json?");
          throw err;
        }
        console.log("INFO: [forge] forging " + config.name + " (" + config.version + ") using schema(s): " + config.schema);
        Forgery = ((function(superClass1) {
          extend(_Class, superClass1);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          return _Class;

        })(YangForge)).merge(config);
        Forgery.configure(hooks.before);
        for (i = 0, len = schemas.length; i < len; i++) {
          schema = schemas[i];
          Forgery.merge((new Forgery).compile(schema));
        }
        Forgery.configure(hooks.after);
        return Forgery;
      }
      this.constructor.copy(input, this.constructor.extract('extensions'));
      YangForge.__super__.constructor.apply(this, arguments);
    }

    return YangForge;

  })(YangCompiler);

  module.exports = YangForge(module, {
    before: function() {},
    after: function() {
      return this.action('import', function(input) {
        return this["import"](input);
      });
    }
  });

}).call(this);
