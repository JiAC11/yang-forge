# web browser interface feature module
#
# This feature add-on module enables generation of a web-based client
# application based on the underlying [express](express.yaml) and
# [websocket](websocket.yaml) feature add-ons to dynamically generate
# user friendly YF runtime browsing capability.
#
# It makes use of following web frameworks:
#
# bootstrap (css)
# handlebars (template)
# coffeescript (language)
# react (facebook UI library)
# socket.io (websocket)
# browserify (generate client-side js bundle)

name: browser
description: web client interface for interacting with YF instance
config: 
  uglify: false

run: !coffee/function |
  (model, runtime) -> 
    source = model.parent
    pkgdir = source.meta 'pkgdir'

    express = source.require 'express'
    exphbs  = source.require 'express-handlebars'
    browser = (->
      @engine 'hbs', exphbs 
        defaultLayout: 'main'
        extname: 'hbs'
        layoutsDir: "#{pkgdir}/views"
      @set 'view engine', 'hbs'
      @set 'views', "#{pkgdir}/views"

    ).call express()

    browserify = source.require 'browserify'
    sbuf = source.require 'stream-buffers'
    yfx = new sbuf.ReadableStreamBuffer initialSize: 1024
    yfx.put "source = atob('#{source.constructor.toSource format: 'yaml', encoding: 'base64'}');", 'utf8'
    yfx.put "Forge = require('#{pkgdir}');", 'utf8'
    b = browserify yfx, basedir: pkgdir
    b.add source.require.resolve 'coffee-script/lib/coffee-script/browser'
    b.add (source.require.resolve 'react'), expose: 'react'
    b.add (source.require.resolve 'zingchart-react'), expose: 'zingchart-react'
    b.add (source.require.resolve 'react-highlight'), expose: 'react-highlight'
    b.ignore x for x in [ 'clim', 'prettyjson' ]
    if @config.uglify is true
      b.transform global: true, sourcemap: false, (source.require 'uglifyify')

    console.info "browser: yangforge browserification started (will take a few seconds)".grey
    b.bundle (err, js) ->
      console.info "browser: yangforge browserification complete".grey
      browser.get '/', (req, res) -> res.render 'index', layout: 'browser', version: source.meta 'version'
      browser.get '/yangforge.js', (req, res) ->
        res.type 'application/javascript'
        res.send js
      highlight = (source.require 'path').resolve pkgdir, 'node_modules/highlight.js/styles'
      browser.get '/highlight/:style.css', (req, res, next) ->
        (source.require 'fs').readFile "#{highlight}/#{req.params.style}.css", (err, data) ->
          return next err if err?
          res.type 'text/css'
          res.send data
    yfx.destroySoon()

    if runtime.express?
      console.info "browser: binding to express /browser".grey
      runtime.express.app.use "/browser", browser

    if runtime.websocket?
      console.info "browser: binding to websocket /browser".grey
      io = runtime.websocket.of '/browser'
      io.on 'connection', (socket) ->
        console.log 'User connected. socket id %s', socket.id
        socket.on 'knock', (rooms) ->
          rooms = [ rooms ] unless Array.isArray rooms
          console.log '[socket:%s] Knocking on %s', socket.id, rooms
          keys = (
            rooms
            .map (room) ->
              # ok this is kinda long and ugly... haha
              (source.access room)?.parent.constructor.toSource? format: 'yaml'
            .filter (x) -> x?
            .map (x) -> source: x
          )
          socket.emit 'enter', keys

        socket.on 'join', (rooms) ->
          console.log '[socket:%s] Joining %s', socket.id, rooms
          if Array.isArray rooms
            socket.join room for room in rooms
          else
            socket.join rooms
        socket.on 'leave', (rooms) ->
          console.log '[socket:%s] Leaving %s', socket.id, rooms
          if Array.isAray rooms
            socket.leave room for room in rooms
          else
            socket.leave rooms

        console.log Object.keys(source.properties)
        socket.emit 'rooms', Object.keys(source.properties)
        
      # watch source and send events
      # source.on 'change', (room, type, message) ->
      #   io.to(room).emit type, message
      
    return browser
