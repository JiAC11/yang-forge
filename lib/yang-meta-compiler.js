// Generated by CoffeeScript 1.9.1
(function() {
  var Meta, YangMetaCompiler,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Meta = require('meta-class');

  YangMetaCompiler = (function(superClass) {
    var assert;

    extend(YangMetaCompiler, superClass);

    function YangMetaCompiler() {
      return YangMetaCompiler.__super__.constructor.apply(this, arguments);
    }

    assert = require('assert');

    YangMetaCompiler.prototype.define = function(type, key, value) {
      var exists;
      exists = this.resolve(type, key);
      if (exists == null) {
        if (this.context == null) {
          this.context = {};
        }
        Meta.copy(this.context, Meta.objectify(type + "." + key, value));
      }
      return void 0;
    };

    YangMetaCompiler.prototype.resolve = function(type, key) {
      var i, prefix, ref, ref1, ref2, ref3;
      ref = key.split(':'), prefix = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), key = ref[i++];
      switch (false) {
        case !(prefix.length > 0):
          return (ref1 = this.resolve('module', prefix[0])) != null ? ref1.get(type + "." + key) : void 0;
        default:
          return (ref2 = this.context) != null ? (ref3 = ref2[type]) != null ? ref3[key] : void 0 : void 0;
      }
    };

    YangMetaCompiler.prototype.parse = function(schema, context, parser) {
      var file, keyword, normalize, params, path, ref, ref1, res, source, statement, stmt, sub;
      if (parser == null) {
        parser = require('yang-parser');
      }
      if (context == null) {
        return this.fork((function() {
          return this.parse(schema, this);
        }));
      }
      if (typeof schema === 'string') {
        return this.parse(parser.parse(schema), context);
      }
      assert(schema instanceof Object, "must pass in proper input to parse");
      statement = schema;
      normalize = function(obj) {
        return ([obj.prf, obj.kw].filter(function(e) {
          return (e != null) && !!e;
        })).join(':');
      };
      keyword = normalize(statement);
      params = ((function() {
        var i, len, ref, results;
        ref = statement.substmts;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          stmt = ref[i];
          results.push(this.parse(stmt, {
            kw: keyword
          }));
        }
        return results;
      }).call(this)).filter(function(e) {
        return e != null;
      }).reduce((function(a, b) {
        return Meta.copy(a, b);
      }), {});
      if (keyword === 'include' && /^(sub)*module$/.test(context.kw)) {
        source = this.get("map." + statement.arg);
        assert(typeof source === 'string', "unable to include '" + statement.arg + "' without mapping defined for source");
        path = require('path');
        file = path.resolve(path.dirname((ref = module.parent) != null ? ref.filename : void 0), source);
        console.log("INFO: including '" + statement.arg + "' using " + file);
        schema = (require('fs')).readFileSync(file, 'utf-8');
        res = this.parse(schema, context);
        sub = res != null ? (ref1 = res.submodule) != null ? ref1[statement.arg] : void 0 : void 0;
        return sub;
      }
      if (keyword === 'extension' && /^(sub)*module$/.test(context.kw)) {
        params.resolver = this.get("extensions." + statement.arg);
        this.define('extension', statement.arg, params);
      }
      switch (false) {
        case !(Object.keys(params).length > 0):
          return Meta.objectify(keyword + "." + statement.arg, params);
        default:
          return Meta.objectify(keyword, statement.arg);
      }
    };

    YangMetaCompiler.prototype.compile = function(input, context) {
      var arg, ext, key, output, params, ref, ref1, ref2, ref3, res, val, validSubs;
      if (context == null) {
        return this.fork(function() {
          var key, obj, override, ref, value;
          obj = this.constructor.extract('extension');
          ref = obj.extension;
          for (key in ref) {
            value = ref[key];
            override = this.get("extensions." + key);
            if (override != null) {
              value.resolver = override;
            }
            this.define('extension', key, value);
          }
          return this.compile(input, this);
        });
      }
      if (input instanceof Function) {
        input = input.call(this);
      }
      if (typeof input === 'string') {
        input = this.parse(input, context);
      }
      assert(input instanceof Object, "must pass in proper input to compile");
      output = (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        return _Class;

      })(Meta);
      output.compiler = this;
      validSubs = context != null ? (ref = context.extension) != null ? ref.sub : void 0 : void 0;
      for (key in input) {
        val = input[key];
        if (!((validSubs == null) || key in validSubs)) {
          continue;
        }
        if (key === 'extension') {
          output.set(key, val);
          continue;
        }
        ext = this.resolve('extension', key);
        assert(ext instanceof Object, "ERROR: cannot compile statement with unknown extension '" + key + "'");
        if (val instanceof Object && (ext.argument != null)) {
          for (arg in val) {
            params = val[arg];
            res = this.compile(params, {
              key: key + "." + arg,
              extension: ext
            });
            output.set(key + "." + arg, params);
            if ((ref1 = ext.resolver) != null) {
              if (typeof ref1.call === "function") {
                ref1.call(output, arg, res);
              }
            }
          }
        } else {
          output.set(key, val);
          if (ext.argument != null) {
            if ((ref2 = ext.resolver) != null) {
              if (typeof ref2.call === "function") {
                ref2.call(output, val, {});
              }
            }
          } else {
            if ((ref3 = ext.resolver) != null) {
              if (typeof ref3.call === "function") {
                ref3.call(output, key, val);
              }
            }
          }
        }
      }
      delete output.compiler;
      return output;
    };

    return YangMetaCompiler;

  })(Meta);

  module.exports = YangMetaCompiler;

}).call(this);
