// Generated by CoffeeScript 1.9.1
(function() {
  var Extension, YangMetaCompiler,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Extension = (function() {
    function Extension(name1, params1) {
      this.name = name1;
      this.params = params1;
      this;
    }

    Extension.prototype.refine = function(params) {
      if (params == null) {
        params = {};
      }
      return this.merge(params);
    };

    Extension.prototype.resolve = function(target, context) {
      var params, resolver;
      resolver = this.resolver;
      if (!(resolver instanceof Function)) {
        return target;
      }
      if (context == null) {
        context = target;
      }
      params = {};
      (target.get('children')).forEach(function(e) {
        return params[e.get('name')] = e;
      });
      return resolver.call(context, target.get('name'), params, target);
    };

    return Extension;

  })();

  YangMetaCompiler = (function(superClass) {
    var compileStatement;

    extend(YangMetaCompiler, superClass);

    function YangMetaCompiler() {
      return YangMetaCompiler.__super__.constructor.apply(this, arguments);
    }

    YangMetaCompiler.set({
      map: {},
      extension: {},
      module: {}
    });

    YangMetaCompiler.map = function(obj) {
      return this.merge('map', obj);
    };

    YangMetaCompiler.extensions = function(obj) {
      var name, ref, resolver, results1;
      results1 = [];
      for (name in obj) {
        resolver = obj[name];
        results1.push((ref = this.get("extension." + name)) != null ? ref.resolver = resolver : void 0);
      }
      return results1;
    };

    YangMetaCompiler.define = function(name, params) {
      var extension;
      if (params == null) {
        params = {};
      }
      extension = this.get("extension." + name);
      if (extension == null) {
        extension = new Extension(name, params);
        this.set("extension." + name, extension);
      }
      return extension;
    };

    YangMetaCompiler.resolver = function(name, resolver) {
      var extension, i, j, len, m, prefix, prf, ref;
      if (typeof name === 'string') {
        ref = name.split(':'), prefix = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), name = ref[i++];
      }
      m = this;
      if (prefix != null) {
        for (j = 0, len = prefix.length; j < len; j++) {
          prf = prefix[j];
          m = m.get("module." + prf);
        }
      }
      extension = m.get("extension." + name);
      if (resolver instanceof Function) {
        if (extension != null) {
          if (typeof extension.set === "function") {
            extension.set('resolver', resolver);
          }
        }
      }
      if (extension == null) {
        extension = Extension;
      }
      return extension;
    };

    YangMetaCompiler.find = function(type, name) {
      var i, j, len, m, prefix, prf, ref;
      if (typeof name === 'string') {
        ref = name.split(':'), prefix = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), name = ref[i++];
      }
      m = this;
      if (prefix != null) {
        for (j = 0, len = prefix.length; j < len; j++) {
          prf = prefix[j];
          m = m.get("module." + prf);
        }
      }
      return m.get(type + "." + name);
    };

    YangMetaCompiler.define('extension', {
      argument: 'extension-name',
      description: '0..1',
      reference: '0..1',
      status: '0..1',
      sub: '0..n',
      resolver: function(name, params) {
        return this.define(name, params);
      }
    });

    YangMetaCompiler.define('argument', {
      'yin-element': '0..1'
    });

    YangMetaCompiler.define('include', {
      argument: 'module',
      resolver: function(name, params) {
        var source, submodule;
        source = this.get("map." + name);
        if (typeof source !== 'string') {
          return;
        }
        submodule = this.compile(function() {
          var file, path, ref;
          path = require('path');
          file = path.resolve(path.dirname((ref = module.parent) != null ? ref.filename : void 0), source);
          console.log("INFO: including '" + name + "' using " + file);
          return (require('fs')).readFileSync(file, 'utf-8');
        });
        this.merge('extension', submodule.get('extension'));
        return submodule;
      }
    });

    compileStatement = function(statement) {
      var keyword, normalize, results, stmt;
      if (!((statement != null) && statement instanceof Object)) {
        return;
      }
      normalize = function(statement) {
        return ([statement.prf, statement.kw].filter(function(e) {
          return (e != null) && !!e;
        })).join(':');
      };
      keyword = normalize(statement);
      results = ((function() {
        var i, len, ref, results1;
        ref = statement.substmts;
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          stmt = ref[i];
          results1.push(compileStatement(stmt));
        }
        return results1;
      })()).filter(function(e) {
        return e != null;
      });
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          yang: keyword,
          name: statement.arg,
          children: results
        });

        return _Class;

      })(require('meta-class'));
    };

    YangMetaCompiler.compile = function(input, parser) {
      var compiler, ref, schema;
      if (parser == null) {
        parser = require('yang-parser');
      }
      if (input == null) {
        return;
      }
      console.log("INFO: compiling a new module using extensions...");
      compiler = this;
      if (input instanceof Function) {
        input = (ref = input.call(this)) != null ? ref : input;
      }
      if (typeof input === 'string') {
        input = compileStatement(parser.parse(schema = input));
      }
      if (schema != null) {
        input.set("schema." + (input.get('name')), schema);
      }
      return input.traverse(function(parent, root) {
        var ref1;
        console.log(this.get('yang'));
        return (ref1 = compiler.find('extension', this.get('yang'))) != null ? ref1.resolve(this, root) : void 0;
      });
    };

    return YangMetaCompiler;

  })(require('meta-class'));

  module.exports = YangMetaCompiler;

}).call(this);
