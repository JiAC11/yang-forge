// Generated by CoffeeScript 1.9.1
(function() {
  var ComputedProperty, PropertyValidationError, StormClass, StormObject, StormProperty,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  StormClass = require('./class');

  PropertyValidationError = (function(superClass) {
    extend(PropertyValidationError, superClass);

    function PropertyValidationError() {
      return PropertyValidationError.__super__.constructor.apply(this, arguments);
    }

    return PropertyValidationError;

  })(Error);

  StormProperty = (function(superClass) {
    extend(StormProperty, superClass);

    StormProperty.set({
      storm: 'property'
    });

    StormProperty.prototype.kind = 'attr';

    function StormProperty(type1, opts1, obj1) {
      var base, base1;
      this.type = type1;
      this.opts = opts1 != null ? opts1 : {};
      this.obj = obj1;
      this.assert(this.obj instanceof StormObject, "cannot register a new property without a reference to an object it belongs to");
      if ((base = this.opts).required == null) {
        base.required = false;
      }
      if ((base1 = this.opts).unique == null) {
        base1.unique = false;
      }

      /**
       * @property value
       */
      this.value = void 0;

      /**
       * @property isDirty
       * @default false
       */
      this.isDirty = false;
    }

    StormProperty.prototype.get = function() {
      if (this.value instanceof StormProperty) {
        return this.value.get();
      } else {
        return this.value;
      }
    };

    StormProperty.prototype.set = function(value, opts) {
      var ArrayEquals, cval, nval;
      if (opts == null) {
        opts = {};
      }
      ArrayEquals = function(a, b) {
        return a.length === b.length && a.every(function(elem, i) {
          return elem === b[i];
        });
      };
      if (value == null) {
        value = (function() {
          switch (false) {
            case typeof this.opts.defaultValue !== 'function':
              return this.opts.defaultValue.call(this.obj);
            default:
              return this.opts.defaultValue;
          }
        }).call(this);
      }
      cval = this.value;
      nval = this.normalize(value);
      if (nval instanceof Array && nval.length > 0) {
        nval = nval.filter(function(e) {
          return e != null;
        });
        if (this.opts.unique === true) {
          nval = nval.unique();
        }
      }
      if (!(opts.skipValidation === true || this.validate(nval))) {
        return new PropertyValidationError(nval);
      }
      this.isDirty = (function() {
        switch (false) {
          case !((cval == null) && (nval != null)):
            return true;
          case this.type !== 'array':
            return !ArrayEquals(cval, nval);
          case cval !== nval:
            return false;
          default:
            return true;
        }
      }).call(this);
      if (this.isDirty === true) {
        this.value = nval;
      }
      return this;
    };

    StormProperty.prototype.validate = function(value) {
      if (value == null) {
        value = this.value;
      }
      if (typeof this.opts.validator === 'function') {
        return this.opts.validator.call(this.obj, value);
      }
      if (value == null) {
        return this.opts.required === false;
      }
      if (value instanceof StormProperty) {
        value = value.get();
      }
      switch (this.type) {
        case 'string' || 'number' || 'boolean' || 'object':
          return typeof value === this.type;
        case 'date':
          return value instanceof Date;
        case 'array':
          return value instanceof Array;
        default:
          return true;
      }
    };

    StormProperty.prototype.normalize = function(value) {
      switch (false) {
        case !(value instanceof Object && typeof value.stormify === 'function'):
          return value.stormify.call(this.obj);
        case !(this.type === 'date' && typeof value === 'string'):
          return new Date(value);
        case !(this.type === 'array' && !(value instanceof Array)):
          if (value != null) {
            return [value];
          } else {
            return [];
          }
          break;
        default:
          return value;
      }
    };

    StormProperty.prototype.serialize = function(format) {
      if (format == null) {
        format = 'json';
      }
      switch (false) {
        case typeof this.opts.serializer !== 'function':
          return this.opts.serializer.call(this.obj, this.value, format);
        case !(this.value instanceof StormProperty):
          return this.value.serialize(format);
        default:
          return this.value;
      }
    };

    return StormProperty;

  })(StormClass);

  ComputedProperty = (function(superClass) {
    extend(ComputedProperty, superClass);

    ComputedProperty.set({
      storm: 'computed'
    });

    ComputedProperty.prototype.kind = 'computed';


    /**
     * @property func
     * @default null
     */

    ComputedProperty.func = function() {
      return null;
    };

    function ComputedProperty(func1, opts, obj) {
      var ref, ref1, type;
      this.func = func1;
      if (opts == null) {
        opts = {};
      }
      console.log('computed');
      console.log(this.func);
      this.assert(typeof this.func === 'function', "cannot register a new ComputedProperty without a function");
      type = (ref = opts.type) != null ? ref : 'computed';
      ComputedProperty.__super__.constructor.call(this, type, opts, obj);
      this.cache = (ref1 = opts.cache) != null ? ref1 : 0;
      if (this.cache > 0) {
        this.cachedOn = new Date();
      }
    }

    ComputedProperty.prototype.isCachedValid = function() {
      return this.cache > 0 && (new Date() - this.cachedOn) / 1000 < this.cache;
    };

    ComputedProperty.prototype.get = function() {
      if (!((this.value != null) && this.isCachedValid())) {
        this.set(this.func.call(this.obj));
        if (this.cache > 0) {
          this.cachedOn = new Date();
        }
      }
      return ComputedProperty.__super__.get.apply(this, arguments);
    };

    ComputedProperty.prototype.serialize = function() {
      return ComputedProperty.__super__.serialize.call(this, this.get());
    };

    return ComputedProperty;

  })(StormProperty);

  StormObject = (function(superClass) {
    extend(StormObject, superClass);

    StormObject.set({
      storm: 'object'
    });

    StormObject.attr = function(type, opts) {
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          type: type,
          opts: opts
        });

        return _Class;

      })(StormProperty);
    };

    StormObject.computed = function(func, opts) {
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          type: func,
          opts: opts
        });

        return _Class;

      })(ComputedProperty);
    };

    StormObject.Property = StormProperty;

    StormObject.ComputedProperty = ComputedProperty;

    function StormObject(data, opts1, container) {
      var StormForm, input, key, ref;
      this.opts = opts1 != null ? opts1 : {};
      this.container = container;
      this._properties = {};
      for (key in this) {
        StormForm = this[key];
        if (!(key !== 'constructor' && ((StormForm != null ? (ref = StormForm.meta) != null ? ref.storm : void 0 : void 0) != null))) {
          continue;
        }
        input = (function() {
          switch (StormForm.get('storm')) {
            case 'object':
              return 'data';
            default:
              return 'type';
          }
        })();
        this.addProperty(key, new StormForm(StormForm.get(input), StormForm.get('opts'), this));
      }
      this.everyProperty(function(key) {
        return this.set(void 0, {
          skipValidation: true
        });
      });
      if (data != null) {
        this.set(data, {
          skipValidation: true
        });
      }
    }

    StormObject.prototype.keys = function() {
      return Object.keys(this._properties);
    };

    StormObject.prototype.addProperty = function(key, property) {
      if (!(this.hasProperty(key)) && property instanceof StormClass) {
        this._properties[key] = property;
      }
      return property;
    };

    StormObject.prototype.removeProperty = function(key) {
      if (this.hasProperty(key)) {
        return delete this._properties[key];
      }
    };

    StormObject.prototype.hasProperty = function(key) {
      return this._properties.hasOwnProperty(key);
    };


    /**
     * `getProperty` supports retrieving property based on composite key such as:
     * 'hello.world.bye'
    #
     * Since this routine is the primary function for get/set operations,
     * you can also use it to specify nested path during those operations.
     */

    StormObject.prototype.getProperty = function(key) {
      var composite, j, len, prop;
      if (key == null) {
        return;
      }
      composite = key != null ? key.split('.') : void 0;
      key = composite.shift();
      if (this.hasProperty(key)) {
        prop = this._properties[key];
      }
      for (j = 0, len = composite.length; j < len; j++) {
        key = composite[j];
        if (prop == null) {
          return;
        }
        prop = typeof prop.getProperty === "function" ? prop.getProperty(key) : void 0;
      }
      return prop;
    };

    StormObject.prototype.get = function() {
      var j, key, keys, len, ref, ref1, result;
      keys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      result = {};
      switch (false) {
        case keys.length !== 0:
          this.everyProperty(function(key) {
            return result[key] = this.get();
          });
          break;
        case keys.length !== 1:
          result = (ref = this.getProperty(keys[0])) != null ? ref.get() : void 0;
          break;
        default:
          for (j = 0, len = keys.length; j < len; j++) {
            key = keys[j];
            result[key] = (ref1 = this.getProperty(key)) != null ? ref1.get() : void 0;
          }
      }
      return result;
    };


    /**
     * `set` is used to place values on matching StormProperty
     * instances. Accepts an object of key/values
    #
     * obj.set hello:'world'
    #
     * { hello: 'world' }
    #
     * obj.set test:'a', sample:'b'
    #
     * obj.set 'test.nested.param':'a', sample:'b'
    #
     * also takes in `opts` as an optional param object to override
     * validations and other special considerations during the `set`
     * execution.
     */

    StormObject.prototype.set = function(obj, opts) {
      var key, ref, value;
      if (!(obj instanceof Object)) {
        return;
      }
      for (key in obj) {
        value = obj[key];
        if ((ref = this.getProperty(key)) != null) {
          ref.set(value, opts);
        }
      }
      return this;
    };

    StormObject.prototype.everyProperty = function(func) {
      var key, prop, ref, results;
      ref = this._properties;
      results = [];
      for (key in ref) {
        prop = ref[key];
        results.push(func != null ? func.call(prop, key) : void 0);
      }
      return results;
    };

    StormObject.prototype.validate = function() {
      return (this.everyProperty(function(key) {
        return {
          name: key,
          isValid: this.validate()
        };
      })).filter(function(e) {
        return e.isValid === false;
      });
    };

    StormObject.prototype.serialize = function(format) {
      var o;
      if (format == null) {
        format = 'json';
      }
      o = (function() {
        switch (format) {
          case 'json':
            return {};
          default:
            return '';
        }
      })();
      this.everyProperty(function(key) {
        switch (format) {
          case 'json':
            return o[key] = this.serialize(format);
          case 'xml':
            return o += ("<" + key + ">") + (this.serialize(format)) + ("</" + key + ">");
        }
      });
      return o;
    };

    StormObject.prototype.clearDirty = function() {
      return this.everyProperty(function() {
        return this.isDirty = false;
      });
    };

    StormObject.prototype.dirtyProperties = function(keys) {
      return (this.everyProperty(function(key) {
        var ref;
        return (ref = this.isDirty) != null ? ref : key;
      })).filter(function(x) {
        if (keys != null) {
          return (x != null) && indexOf.call(keys, x) >= 0;
        } else {
          return x != null;
        }
      });
    };

    StormObject.prototype.isDirty = function(keys) {
      if ((keys != null) && !(keys instanceof Array)) {
        keys = [keys];
      }
      return (this.dirtyProperties(keys)).length > 0;

      /* for future optimization reference
      dirty = @dirtyProperties().join ' '
      keys.some (prop) -> ~dirty.indexOf prop
       */
    };

    return StormObject;

  })(StormClass);

  module.exports = StormObject;

}).call(this);
