// Generated by CoffeeScript 1.9.1
(function() {
  var StormClass, StormObject, YangContainer, YangCore, YangExtension, YangGrouping, YangList, YangListEntry, YangModule, YangObject, YangProperty, YangRemoteProcedure, toSource,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  StormClass = require('../storm/class');

  StormObject = require('../storm/object');

  YangModule = require('./module');

  YangObject = (function(superClass) {
    extend(YangObject, superClass);

    function YangObject() {
      return YangObject.__super__.constructor.apply(this, arguments);
    }

    return YangObject;

  })(StormObject);


  /**
   * `YangGrouping` is purely a logical schema abstraction to allow
   * "tagging" of sections of schema for reference use by other YANG
   * schemas.
  #
   * So although we do create a `StormObject` mapping within the class
   * hierarchy of the overall `YangModel`, it should not be directly
   * referenced as property setter/getter.
   */

  YangGrouping = (function(superClass) {
    extend(YangGrouping, superClass);

    function YangGrouping() {
      return YangGrouping.__super__.constructor.apply(this, arguments);
    }

    return YangGrouping;

  })(YangObject);

  YangContainer = (function(superClass) {
    extend(YangContainer, superClass);

    function YangContainer() {
      return YangContainer.__super__.constructor.apply(this, arguments);
    }

    return YangContainer;

  })(YangObject);

  YangExtension = (function(superClass) {
    extend(YangExtension, superClass);

    function YangExtension() {
      return YangExtension.__super__.constructor.apply(this, arguments);
    }

    return YangExtension;

  })(YangObject);

  YangListEntry = (function(superClass) {
    extend(YangListEntry, superClass);

    function YangListEntry() {
      return YangListEntry.__super__.constructor.apply(this, arguments);
    }

    return YangListEntry;

  })(YangObject);

  YangProperty = (function(superClass) {
    extend(YangProperty, superClass);

    function YangProperty() {
      return YangProperty.__super__.constructor.apply(this, arguments);
    }

    return YangProperty;

  })(YangObject.Property);

  YangList = (function(superClass) {
    extend(YangList, superClass);

    YangList.Entry = YangListEntry;

    function YangList(model, opts, obj) {
      this.model = model;
      YangList.__super__.constructor.call(this, 'array', opts, obj);
    }

    return YangList;

  })(YangProperty);

  toSource = require('tosource');

  YangRemoteProcedure = (function(superClass) {
    extend(YangRemoteProcedure, superClass);

    function YangRemoteProcedure() {
      return YangRemoteProcedure.__super__.constructor.apply(this, arguments);
    }

    YangRemoteProcedure.toSource = function() {
      if (this.prototype.exec instanceof Function) {
        return toSource(this.prototype.exec);
      }
    };

    YangRemoteProcedure.prototype.exec = function() {
      throw new Error("cannot invoke RPC without function defined");
    };

    return YangRemoteProcedure;

  })(YangObject);

  YangCore = (function(superClass) {
    var jsonParser, textParser, yangSpec;

    extend(YangCore, superClass);

    YangCore.set({
      module: YangModule,
      grouping: YangGrouping,
      container: YangContainer,
      list: YangList,
      extension: YangExtension,
      leaf: YangProperty,
      'leaf-list': YangProperty,
      rpc: YangRemoteProcedure
    });

    yangSpec = require('./yang-core-spec-v1');

    textParser = require('yang-parser');

    jsonParser = require('./yang-json-parser');

    function YangCore(map1) {
      this.map = map1 != null ? map1 : yangSpec;
    }

    YangCore.prototype.create = function(keyword, args) {
      var Override, functions, k, name, ref, statics, v;
      ref = keyword.split(' '), keyword = ref[0], name = ref[1];
      statics = {};
      functions = {};
      for (k in args) {
        v = args[k];
        if (v instanceof Function) {
          functions[k] = v;
        } else {
          statics[k] = v;
        }
      }
      Override = this.constructor.get(keyword);
      if ((Override != null) && (typeof Override.get === "function" ? Override.get('storm') : void 0)) {
        return (function(superClass1) {
          extend(_Class, superClass1);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.set({
            yang: keyword
          });

          if (name != null) {
            _Class.set({
              name: name
            });
          }

          _Class.extend(statics);

          _Class.include(functions);

          return _Class;

        })(Override);
      } else {
        return (function(superClass1) {
          extend(_Class, superClass1);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.set({
            yang: keyword
          });

          _Class.extend(statics);

          _Class.include(functions);

          return _Class;

        })(YangObject);
      }
    };

    YangCore.generate = function(schema) {
      var statement;
      assert(schema != null, "must pass in input schema text to process for YANG");
      statement = (function() {
        switch (false) {
          case typeof schema !== 'string':
            return textParser.parse(schema);
          case typeof schema !== 'object':
            return jsonParser.parse(schema);
          default:
            return null;
        }
      })();
      assert((statement != null) && statement.kw === 'module', "must pass in YANG module schema definition");
      if (this.groupings == null) {
        this.groupings = {};
      }
      if (this.types == null) {
        this.types = {};
      }
      return this.processStatement(statement);
    };

    YangCore.resolve = function(grouping, props) {
      if (!this.groupings.hasOwnProperty(grouping)) {
        console.log("WARNING: trying to 'uses' using " + grouping + " identifier not found");
        return null;
      }
      return this.groupings[grouping];
    };

    YangCore.processStatement = function(statement, map) {
      var hasMany, importModule, includeModule, keyword, param, prefix, properties, resolveMap, results, subs, value;
      if (map == null) {
        map = this.map;
      }
      prefix = statement.prf, keyword = statement.kw, param = statement.arg, subs = statement.substmts;
      resolveMap = (function(_this) {
        return function(map, key) {
          var ref, v, value;
          value = (ref = map[key]) != null ? ref : _this.map[key];
          switch (false) {
            case !(value instanceof Function):
              return value();
            case !(value instanceof Array):
              v = value[0];
              v = (function() {
                switch (false) {
                  case !(v instanceof Function):
                    return v();
                  default:
                    return v;
                }
              })();
              return {
                type: 'array',
                value: v
              };
            default:
              return value;
          }
        };
      })(this);
      map = resolveMap(map, keyword);
      if ((map != null ? map.type : void 0) === 'array') {
        hasMany = true;
        map = map.value;
      }
      if (map == null) {
        console.log("WARNING: unsupported YANG " + keyword + " found, ignoring...");
        return;
      }
      results = ((function() {
        var i, len, results1;
        results1 = [];
        for (i = 0, len = subs.length; i < len; i++) {
          statement = subs[i];
          results1.push(this.processStatement(statement, map));
        }
        return results1;
      }).call(this)).filter(function(e) {
        return (e != null) && (e.value != null);
      });
      if (!(results.length > 0)) {
        return {
          name: keyword,
          value: param
        };
      }
      properties = results.reduce((function(a, b) {
        a[b.name] = b.value;
        return a;
      }), {});
      if (keyword === 'module' || keyword === 'submodule') {
        return this.create(keyword + " " + param, properties);
      }
      importModule = function(module, opts) {
        return null;
      };
      includeModule = function(module, opts) {
        return null;
      };
      value = (function() {
        switch (keyword) {
          case 'import':
            return importModule(param, properties);
          case 'include':
            return includeModule(param, properties);
          case 'uses':
            return this.resolve(param, properties);
          case 'extension':
          case 'grouping':
          case 'rpc':
            return this.create(keyword + " " + param, properties);
          default:
            return this.create(keyword, properties);
        }
      }).call(this);
      switch (keyword) {
        case 'grouping':
          this.groupings[param] = value;
          break;
        case 'extension':
          this.map[param] = this.map.container;
          break;
        case 'typedef':
          uncreated;
          break;
        case 'list':
          value.set({
            type: this.create('container', properties)
          });
          break;
        case 'leaf':
        case 'leaf-list':
          value.set({
            type: properties.type
          });
      }
      return {
        name: param,
        value: value
      };
    };

    return YangCore;

  })(StormClass);

  module.exports = YangCore;

}).call(this);
