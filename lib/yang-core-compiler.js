// Generated by CoffeeScript 1.9.1
(function() {
  var MetaClass, YangCoreCompiler,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  MetaClass = require('meta-class');

  YangCoreCompiler = (function(superClass) {
    extend(YangCoreCompiler, superClass);

    function YangCoreCompiler() {
      return YangCoreCompiler.__super__.constructor.apply(this, arguments);
    }

    YangCoreCompiler.set({
      module: {
        resolver: function(arg, params) {
          return (function(superClass1) {
            extend(_Class, superClass1);

            function _Class() {
              return _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(this);
        },
        extension: '0..n',
        supplement: '0..n'
      },
      extension: {
        resolver: function(arg, params) {
          this.merge(arg, params);
          return null;
        },
        argument: '0..1',
        description: '0..1',
        reference: '0..1',
        status: '0..1',
        sub: '0..n'
      },
      argument: {
        'yin-element': '0..1'
      },
      description: {
        'argument text': {
          'yin-element': true
        }
      },
      reference: {
        'argument text': {
          'yin-element': true
        }
      },
      status: {
        argument: 'value'
      },
      value: {
        argument: 'value',
        any: true
      },
      'yang-version': {
        argument: 'value'
      },
      'yin-element': {
        argument: 'value'
      },
      sub: {
        argument: 'extension-name',
        resolver: function(arg, params) {
          return params != null ? params.value : void 0;
        },
        value: '0..1'
      },
      supplement: {
        argument: 'extension-name',
        resolver: function(arg, params) {
          this.merge(arg, params);
          return null;
        },
        sub: '0..n'
      }
    });

    YangCoreCompiler.parser = require('yang-parser');

    YangCoreCompiler.preprocess = function(schema) {
      var extensions, i, j, len, len1, params, ref, ref1, statement, stmt, substmt;
      statement = this.parser.parse(schema);
      if (statement == null) {
        return;
      }
      extensions = {};
      ref = statement.substmts;
      for (i = 0, len = ref.length; i < len; i++) {
        stmt = ref[i];
        if (!(stmt.kw === 'extension')) {
          continue;
        }
        params = {};
        ref1 = stmt.substmts;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          substmt = ref1[j];
          if (substmt.substmts.length === 0) {
            params[substmt.kw] = substmt.arg;
          }
        }
        extensions[stmt.arg] = params;
      }
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set(extensions);

        return _Class;

      })(MetaClass);
    };

    YangCoreCompiler.compile = function(schema, meta) {
      var output;
      if (meta == null) {
        meta = {};
      }
      if (meta instanceof Function) {
        this.merge(meta);
      }
      output = this.compileStatement(this.parser.parse(schema));
      return output != null ? output.value : void 0;
    };

    YangCoreCompiler.compileStatement = function(statement) {
      var keyword, meta, normalize, params, ref, ref1, results, stmt, target, value;
      if (!((statement != null) && statement instanceof Object)) {
        return;
      }
      normalize = function(statement) {
        return ([statement.prf, statement.kw].filter(function(e) {
          return (e != null) && !!e;
        })).join(':');
      };
      keyword = normalize(statement);
      target = this.get(keyword);
      if (target == null) {
        console.log("WARN: unrecognized keyword extension '" + keyword + "', skipping...");
        return null;
      }
      if (!(((ref = statement.substmts) != null ? ref.length : void 0) > 0)) {
        return {
          name: statement.kw,
          value: statement.arg
        };
      }
      results = (function() {
        var i, len, ref1, results1;
        ref1 = statement.substmts;
        results1 = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          stmt = ref1[i];
          if ((function() {
            switch (false) {
              case !((meta = this.get(keyword)) == null):
                console.log("WARN: unable to find metadata for " + keyword);
                return false;
              case meta.any !== true:
                return true;
              case !!meta.hasOwnProperty(normalize(stmt)):
                console.log("WARN: " + keyword + " does not have sub-statement declared for " + (normalize(stmt)));
                return false;
              default:
                return true;
            }
          }).call(this)) {
            results1.push(this.compileStatement(stmt));
          }
        }
        return results1;
      }).call(this);
      params = (results.filter(function(e) {
        return (e != null) && (e.value != null);
      })).reduce((function(a, b) {
        a[b.name] = b.value;
        return a;
      }), {});
      value = (function() {
        switch (false) {
          case !(target.resolver instanceof Function):
            return target.resolver.call(this, statement.arg, params, target);
          default:
            return (function(superClass1) {
              extend(_Class, superClass1);

              function _Class() {
                return _Class.__super__.constructor.apply(this, arguments);
              }

              return _Class;

            })(MetaClass);
        }
      }).call(this);
      if (value != null) {
        if (typeof value.set === "function") {
          value.set({
            yang: keyword
          });
        }
      }
      if (value != null) {
        if (typeof value.extend === "function") {
          value.extend(params);
        }
      }
      if ((statement.arg != null) && ((value != null ? value.set : void 0) != null)) {
        this.set(statement.kw + ":" + statement.arg, value);
      }
      return {
        name: (ref1 = statement.arg) != null ? ref1 : statement.kw,
        value: value
      };
    };

    return YangCoreCompiler;

  })(MetaClass);

  module.exports = YangCoreCompiler;


  /* DEPRECATED but retained for temporary reference...
      text: (require 'yang-parser').parse
      json: (obj) ->
        statements = []
        for key, val of obj
          [ kw, arg ] = key.split ' '
          [ prf, kw ] = kw.split ':'
          unless kw?
            kw = prf
            prf = ''
          substmts = undefined
          switch
            when val instanceof Function then arg ?= val
            when val not instanceof Object then arg ?= val
            else
              substmts = @json val
              unless substmts instanceof Array
                substmts = [ substmts ]
          statements.push prf: prf, kw: kw, arg: arg, substmts: substmts
        switch
          when statements.length > 1 then statements
          when statements.length is 1 then statements[0]
          else undefined
      source: (func) -> ((require 'tosource') func) if func instanceof Function
   */

}).call(this);
