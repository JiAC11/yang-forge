// Generated by CoffeeScript 1.9.1

/**
 * @module YangCoreCompiler
 * @main YangCoreCompiler
 */

(function() {
  var YangCoreCompiler,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  YangCoreCompiler = (function(superClass) {
    extend(YangCoreCompiler, superClass);

    function YangCoreCompiler() {
      return YangCoreCompiler.__super__.constructor.apply(this, arguments);
    }

    YangCoreCompiler.set({
      module: {
        extension: '0..n'
      },
      extension: {
        resolver: function(arg, params) {
          this.merge(arg, params);
          return null;
        },
        argument: '0..1',
        description: '0..1',
        reference: '0..1',
        status: '0..1',
        pre: '0..1',
        sub: '0..1'
      },
      argument: {
        'yin-element': '0..1'
      },
      description: {
        'argument text': {
          'yin-element': true
        }
      },
      reference: {
        'argument text': {
          'yin-element': true
        }
      },
      status: {
        argument: 'value'
      },
      value: {
        argument: 'value'
      },
      resolver: {
        argument: 'function'
      },
      sub: {
        argument: 'keyword',
        resolver: function(arg, params) {
          return params != null ? params.value : void 0;
        },
        value: '0..1'
      },
      'yang-version': {
        argument: 'value'
      },
      'yin-element': {
        argument: 'value'
      }
    });

    YangCoreCompiler.parser = {
      text: (require('yang-parser')).parse,
      json: function(obj) {
        var arg, key, kw, prf, ref, ref1, statements, substmts, val;
        statements = [];
        for (key in obj) {
          val = obj[key];
          ref = key.split(' '), kw = ref[0], arg = ref[1];
          ref1 = kw.split(':'), prf = ref1[0], kw = ref1[1];
          if (kw == null) {
            kw = prf;
            prf = '';
          }
          substmts = void 0;
          switch (false) {
            case !(val instanceof Function):
              if (arg == null) {
                arg = val;
              }
              break;
            case val instanceof Object:
              if (arg == null) {
                arg = val;
              }
              break;
            default:
              substmts = this.json(val);
              if (!(substmts instanceof Array)) {
                substmts = [substmts];
              }
          }
          statements.push({
            prf: prf,
            kw: kw,
            arg: arg,
            substmts: substmts
          });
        }
        switch (false) {
          case !(statements.length > 1):
            return statements;
          case statements.length !== 1:
            return statements[0];
          default:
            return void 0;
        }
      },
      source: function(func) {
        if (func instanceof Function) {
          return (require('tosource'))(func);
        }
      }
    };

    YangCoreCompiler.compile = function(schema, opts) {
      var output, ref;
      if (opts == null) {
        opts = {};
      }
      output = this.compileStatement((function() {
        switch (false) {
          case typeof schema !== 'string':
            return this.parser.text(schema);
          case typeof schema !== 'object':
            return this.parser.json(schema);
          default:
            return null;
        }
      }).call(this));
      if (opts.compiler === true) {
        if (output != null) {
          if ((ref = output.value) != null) {
            if (typeof ref.extend === "function") {
              ref.extend(this);
            }
          }
        }
      }
      return output != null ? output.value : void 0;
    };


    /**
     * `compileStatement` performs recursive compilation of passed in
     * statement and sub-statements
     */

    YangCoreCompiler.compileStatement = function(statement) {
      var keyword, meta, normalize, params, ref, ref1, results, stmt, target, value;
      if (!((statement != null) && statement instanceof Object)) {
        return;
      }
      normalize = function(statement) {
        return ([statement.prf, statement.kw].filter(function(e) {
          return (e != null) && !!e;
        })).join(':');
      };
      keyword = normalize(statement);
      target = this.get(keyword);
      if (target == null) {
        console.log("unrecognized keyword extension '" + keyword + "', skipping...");
        return null;
      }
      if (!(((ref = statement.substmts) != null ? ref.length : void 0) > 0)) {
        return {
          name: statement.kw,
          value: statement.arg
        };
      }
      results = (function() {
        var i, len, ref1, results1;
        ref1 = statement.substmts;
        results1 = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          stmt = ref1[i];
          if ((function() {
            switch (false) {
              case !((meta = this.get(keyword)) == null):
                console.log("unable to find metadata for " + keyword);
                return false;
              case !!meta.hasOwnProperty(normalize(stmt)):
                console.log(keyword + " does not have sub statement declared for " + (normalize(stmt)));
                return false;
              default:
                return true;
            }
          }).call(this)) {
            results1.push(this.compileStatement(stmt));
          }
        }
        return results1;
      }).call(this);
      params = (results.filter(function(e) {
        return (e != null) && (e.value != null);
      })).reduce((function(a, b) {
        a[b.name] = b.value;
        return a;
      }), {});
      value = (function() {
        switch (false) {
          case !(target.resolver instanceof Function):
            return target.resolver.call(this, statement.arg, params, target);
          default:
            return (function(superClass1) {
              extend(_Class, superClass1);

              function _Class() {
                return _Class.__super__.constructor.apply(this, arguments);
              }

              return _Class;

            })(require('meta-class'));
        }
      }).call(this);
      if (value != null) {
        if (typeof value.set === "function") {
          value.set({
            yang: keyword
          });
        }
      }
      if (value != null) {
        if (typeof value.extend === "function") {
          value.extend(params);
        }
      }
      if ((statement.arg != null) && ((value != null ? value.set : void 0) != null)) {
        this.set(statement.kw + ":" + statement.arg, value);
      }
      return {
        name: (ref1 = statement.arg) != null ? ref1 : statement.kw,
        value: value
      };
    };

    return YangCoreCompiler;

  })(require('meta-class'));

  module.exports = YangCoreCompiler;

}).call(this);
