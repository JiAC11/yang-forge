// Generated by CoffeeScript 1.9.1
(function() {
  var Meta, MetaCompiler, compiler, options, output,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Meta = require('./meta-class');

  options = {
    map: {
      'yang-v1-extensions': '../yang-v1-extensions.yang'
    },
    extensions: {
      module: function(key, value) {
        return this.mixin(value);
      },
      container: function(key, value) {
        return this.bind(key, value);
      },
      "enum": function(key, value) {
        return this.bind(key, value);
      },
      leaf: function(key, value) {
        return this.bind(key, value);
      },
      'leaf-list': function(key, value) {
        return this.bind(key, value);
      },
      list: function(key, value) {
        return this.bind(key, ((function(superClass) {
          extend(_Class, superClass);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          return _Class;

        })(Meta)).set({
          model: value
        }));
      },
      grouping: function(key, value) {
        return this.compiler.define('grouping', key, value);
      },
      typedef: function(key, value) {
        return this.compiler.define('type', key, value);
      },
      uses: function(key, value) {
        var Grouping, ref;
        Grouping = (ref = this.compiler.resolve('grouping', key)) != null ? ref : Meta;
        return this.mixin(((function(superClass) {
          extend(_Class, superClass);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          return _Class;

        })(Grouping)).merge(value));
      },
      augment: function(key, value) {
        return this.merge(value);
      },
      refine: function(key, value) {
        return this.merge(value);
      },
      type: function(key, value) {
        var Type;
        Type = this.compiler.resolve('type', key);
        if (Type != null) {
          return this.set('type', Type);
        }
      },
      rpc: function(key, value) {
        this.set("methods." + key, value);
        return this.bind(key, this.compiler.get("procedures." + key));
      },
      input: function(key, value) {
        return this.bind('input', value);
      },
      output: function(key, value) {
        return this.bind('output', value);
      },
      notification: function(key, value) {
        return this.compiler.define('notification', key, value);
      },
      'belongs-to': function(key, value) {
        return this.compiler.define('module', value.get('prefix'), this.compiler.resolve('module', key));
      },
      "import": function(key, value) {
        var mod, prefix, ref;
        mod = this.compiler["import"]({
          name: key
        });
        prefix = (ref = value.get('prefix')) != null ? ref : mod.get('prefix');
        return this.compiler.define('module', prefix, mod);
      }
    },
    procedures: {
      "import": function(input) {
        return this["import"](input);
      }
    }
  };

  MetaCompiler = require('./yang-meta-compiler');

  compiler = new MetaCompiler(options);

  output = compiler.compile(function() {
    var file, path;
    path = require('path');
    file = path.resolve(__dirname, '../yang-compiler.yang');
    return (require('fs')).readFileSync(file, 'utf-8');
  });

  output.mixin(MetaCompiler, require('./yang-compiler-mixin'));

  module.exports = output;

}).call(this);
