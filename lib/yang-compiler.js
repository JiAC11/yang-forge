// Generated by CoffeeScript 1.9.1
(function() {
  var Compiler, output, something;

  Compiler = require('./yang-meta-compiler');

  output = Compiler.compile(function() {
    var file, path;
    this.map({
      'yang-v1-extensions': '../yang-v1-extensions.yang'
    });
    path = require('path');
    file = path.resolve(__dirname, '../yang-compiler.yang');
    return (require('fs')).readFileSync(file, 'utf-8');
  }).configure(function() {
    this.mixin(Compiler);
    this.extensions({
      augment: function(arg, params) {
        var ref;
        if ((ref = this[arg]) != null) {
          if (typeof ref.extend === "function") {
            ref.extend(params);
          }
        }
        return null;
      },
      refine: function(arg, params) {
        var ref;
        if ((ref = this[arg]) != null) {
          if (typeof ref.extend === "function") {
            ref.extend(params);
          }
        }
        return null;
      },
      "import": function(arg, params) {
        var mod, ref;
        mod = (ref = this.get("module." + arg)) != null ? ref : this["import"](arg);
        if (params.prefix == null) {
          params.prefix = mod != null ? mod.prefix : void 0;
        }
        this.set("module." + params.prefix, mod);
        return null;
      }
    });
    this.resolver('belongs-to', function(arg, params) {
      this.set("module/" + params.prefix, this.get("module/" + arg));
      return null;
    });
    this.resolver('grouping', function(arg, params, meta) {
      return this.set("grouping/" + arg, meta);
    });
    this.resolver('uses', function(arg, params) {
      return this.get("grouping/" + arg);
    });
    this.merge('yang/feature', {
      meta: true
    });
    this.merge('yang/grouping', {
      meta: true
    });
    this.merge('yang/identity', {
      meta: true
    });
    this.merge('yang/revision', {
      meta: true
    });
    this.merge('yang/typedef', {
      meta: true
    });
    this.merge('yang/module', {
      "export": true
    });
    this.merge('yang/submodule', {
      "export": true
    });
    this.merge('yang/rpc', {
      "export": true
    });
    return this.merge('yang/notification', {
      "export": true
    });
  }).compile(function() {
    return this;
  });

  module.exports = output;

  something = function() {
    this.set({
      map: {},
      importers: []
    });
    this.register = function(regex, func) {
      if (regex instanceof RegExp && func instanceof Function) {
        return (this.get('importers')).unshift({
          regex: regex,
          f: func
        });
      }
    };
    this.resolveFile = function(filename) {
      var ref;
      switch (false) {
        case !path.isAbsolute(filename):
          return filename;
        default:
          return path.resolve(path.dirname((ref = module.parent) != null ? ref.filename : void 0), filename);
      }
    };
    this.register(/.*\.yang$/, function(filename) {
      return this.compile({
        schema: this.resolveFile(filename)
      });
    });
    this.register(/.*/, function(filename) {
      return require(filename);
    });
    return this["import"] = function(name) {
      var err, i, importer, len, m, ref, source;
      source = this.get("map." + name);
      ref = this.get('importers');
      for (i = 0, len = ref.length; i < len; i++) {
        importer = ref[i];
        if (!(source != null ? typeof source.match === "function" ? source.match(importer.regex) : void 0 : void 0)) {
          continue;
        }
        try {
          m = importer.f.call(this, source);
        } catch (_error) {
          err = _error;
          continue;
        }
        this.set("module/" + name, m);
        return m;
      }
      if (err == null) {
        err = "no matching 'source' found in the map";
      }
      console.log("WARN: unable to import module '" + name + "' due to " + err);
      return void 0;
    };
  };

}).call(this);
