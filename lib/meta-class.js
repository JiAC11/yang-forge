// Generated by CoffeeScript 1.9.1
(function() {
  var Meta,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Meta = (function() {
    var assert;

    Meta.__meta__ = {
      bindings: {}
    };

    Meta.__version__ = 3;

    assert = require('assert');

    Meta["instanceof"] = function(obj) {
      return (obj != null ? obj["instanceof"] : void 0) === arguments.callee;
    };

    Meta.copy = function(dest, src) {
      var p, ref;
      for (p in src) {
        if (((ref = src[p]) != null ? ref.constructor : void 0) === Object) {
          if (dest[p] == null) {
            dest[p] = {};
          }
          arguments.callee(dest[p], src[p]);
        } else {
          dest[p] = src[p];
        }
      }
      return dest;
    };

    Meta.objectify = function(key, val) {
      var composite, k, last, obj, ref, root;
      if (key instanceof Object) {
        return key;
      }
      composite = (ref = (key != null ? key.split('.') : void 0).filter(function(e) {
        return !!e;
      })) != null ? ref : [];
      if (!composite.length) {
        return val != null ? val : {};
      }
      obj = root = {};
      while ((k = composite.shift())) {
        last = {
          r: root,
          k: k
        };
        root = root[k] = {};
      }
      last.r[last.k] = val;
      return obj;
    };

    Meta.get = function(key) {
      var composite, ref, root;
      if (!((key != null) && typeof key === 'string')) {
        return;
      }
      root = (ref = this.__meta__) != null ? ref : this;
      composite = (key != null ? key.split('.') : void 0).filter(function(e) {
        return !!e;
      });
      while ((key = composite.shift())) {
        root = root != null ? root[key] : void 0;
      }
      return root;
    };

    Meta.extract = function() {
      var i, key, keys, len, res;
      keys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      res = {};
      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        Meta.copy(res, Meta.objectify(key, this.get(key)));
      }
      return res;
    };

    Meta.match = function(regex) {
      var k, obj, ref, root, v;
      root = (ref = this.__meta__) != null ? ref : this;
      obj = {};
      for (k in root) {
        v = root[k];
        if (k.match(regex)) {
          obj[k] = v;
        }
      }
      return obj;
    };

    Meta.set = function(key, val) {
      var obj;
      obj = Meta.objectify(key, val);
      this.__meta__ = Meta.copy(Meta.copy({}, this.__meta__), obj);
      return this;
    };

    Meta.merge = function(key, obj) {
      var k, ref, ref1, target, v;
      if (typeof key !== 'string') {
        ref1 = (ref = key.__meta__) != null ? ref : key;
        for (k in ref1) {
          v = ref1[k];
          this.merge(k, v);
        }
        return this;
      }
      target = this.get(key);
      switch (false) {
        case !(target == null):
          this.set(key, obj);
          break;
        case !((Meta["instanceof"](target)) && (Meta["instanceof"](obj))):
          target.merge(obj);
          break;
        case !(target instanceof Function && obj instanceof Function):
          if (typeof target.mixin === "function") {
            target.mixin(obj);
          }
          break;
        case !(target instanceof Array && obj instanceof Array):
          Array.prototype.push.apply(target, obj);
          break;
        case !(target instanceof Object && obj instanceof Object):
          for (k in obj) {
            v = obj[k];
            target[k] = v;
          }
          break;
        default:
          assert(typeof target === typeof obj, "cannot perform 'merge' for " + key + " with existing value type conflicting with passed-in value");
          this.set(key, obj);
      }
      return this;
    };

    Meta.bind = function(key, obj) {
      if ((this.get("bindings." + key)) == null) {
        return this.set("bindings." + key, obj);
      }
    };

    Meta.configure = function(f) {
      if (f != null) {
        if (typeof f.call === "function") {
          f.call(this);
        }
      }
      return this;
    };

    Meta.extend = function(obj) {
      var k, v;
      for (k in obj) {
        v = obj[k];
        if (k !== '__super__' && indexOf.call(Object.keys(Meta), k) < 0) {
          this[k] = v;
        }
      }
      return this;
    };

    Meta.include = function(obj) {
      var k, v;
      for (k in obj) {
        v = obj[k];
        if (k !== 'constructor' && indexOf.call(Object.keys(Meta.prototype), k) < 0) {
          this.prototype[k] = v;
        }
      }
      return this;
    };

    Meta.mixin = function() {
      var i, len, obj, objs;
      objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (i = 0, len = objs.length; i < len; i++) {
        obj = objs[i];
        if (!(obj instanceof Object)) {
          continue;
        }
        this.extend(obj);
        this.include(obj.prototype);
        if (!Meta["instanceof"](obj)) {
          continue;
        }
        this.merge(obj.extract('bindings'));
      }
      return this;
    };

    function Meta(value) {
      var k, ref, v;
      this.value = value != null ? value : {};
      assert(this.value instanceof Object, "invalid input value for meta class construction");
      ref = this.constructor.get('bindings');
      for (k in ref) {
        v = ref[k];
        this.attach(k, v);
      }
    }

    Meta.prototype.attach = function(key, val) {
      var k, results, v;
      switch (false) {
        case !(Meta["instanceof"](val)):
          if (this.properties == null) {
            this.properties = {};
          }
          this.properties[key] = new val(this.value[key]);
          return this.isContainer = true;
        case !(val instanceof Function):
          if (this.methods == null) {
            this.methods = {};
          }
          return this.methods[key] = val;
        case (val != null ? val.constructor : void 0) !== Object:
          results = [];
          for (k in val) {
            v = val[k];
            results.push(this.attach(k, v));
          }
          return results;
          break;
        default:
          if (this.statics == null) {
            this.statics = {};
          }
          return this.statics[key] = val;
      }
    };

    Meta.prototype.fork = function(f) {
      return f != null ? typeof f.call === "function" ? f.call(new this.constructor(this.get())) : void 0 : void 0;
    };

    Meta.prototype.extract = Meta.extract;

    Meta.prototype.getProperty = function(key) {
      var prop, ref, ref1, ref2, rest;
      return this.properties[key];
      ref2 = (ref = (ref1 = key != null ? typeof key.split === "function" ? key.split('.') : void 0 : void 0) != null ? ref1.filter(function(e) {
        return !!e;
      }) : void 0) != null ? ref : [], key = ref2[0], rest = 2 <= ref2.length ? slice.call(ref2, 1) : [];
      if (!((key != null) && typeof key === 'string')) {
        return;
      }
      prop = this.properties[key];
      switch (false) {
        case rest.length !== 0:
          return prop;
        default:
          return prop != null ? typeof prop.getProperty === "function" ? prop.getProperty(rest.join('.')) : void 0 : void 0;
      }
    };

    Meta.prototype.get = function(key) {
      var k, ref, ref1, ref2, ref3, ref4, rest, v;
      ref2 = (ref = (ref1 = key != null ? typeof key.split === "function" ? key.split('.') : void 0 : void 0) != null ? ref1.filter(function(e) {
        return !!e;
      }) : void 0) != null ? ref : [], key = ref2[0], rest = 2 <= ref2.length ? slice.call(ref2, 1) : [];
      switch (false) {
        case !(this.isContainer && (key != null)):
          return (ref3 = this.getProperty(key)) != null ? ref3.get(rest.join('.')) : void 0;
        case !this.isContainer:
          ref4 = this.properties;
          for (k in ref4) {
            v = ref4[k];
            this.value[k] = v.get();
          }
          return this.value;
        case key == null:
          rest.unshift(key);
          return Meta.get.call(this.value, rest.join('.'));
        default:
          return this.value;
      }
    };

    Meta.prototype.set = function(key, val) {
      var k, ref, ref1, ref2, ref3, rest, v;
      if (!key) {
        key = val;
      }
      if (this.isContainer) {
        switch (false) {
          case typeof key !== 'string':
            ref2 = (ref = (ref1 = key != null ? typeof key.split === "function" ? key.split('.') : void 0 : void 0) != null ? ref1.filter(function(e) {
              return !!e;
            }) : void 0) != null ? ref : [], key = ref2[0], rest = 2 <= ref2.length ? slice.call(ref2, 1) : [];
            if ((ref3 = this.getProperty(key)) != null) {
              ref3.set(rest.join('.'), val);
            }
            break;
          case !(key instanceof Object):
            for (k in key) {
              v = key[k];
              this.set(k, v);
            }
        }
      } else {
        if (key == null) {
          key = {};
        }
        Meta.copy(this.value, Meta.objectify(key, val));
      }
      return this;
    };

    Meta.prototype.invoke = function() {
      var args, method, name, ref;
      name = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      method = (ref = this.methods) != null ? ref[name] : void 0;
      assert(method instanceof Function, "cannot invoke undefined '" + name + "' method");
      return method.apply(this, args);
    };

    return Meta;

  })();

  module.exports = Meta;

}).call(this);
