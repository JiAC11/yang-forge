// Generated by CoffeeScript 1.9.1
(function() {
  var compiler, file, path, schema;

  compiler = require('./yang-core-compiler');

  path = require('path');

  file = path.resolve(__dirname, '../yang-v1-compiler.yang');

  schema = (require('fs')).readFileSync(file, 'utf-8');

  module.exports = (compiler.compile(schema)).configure(function() {
    this.extend(compiler);
    this.compile = function(source) {
      return compiler.compile.call(this, (function() {
        switch (false) {
          case typeof source !== 'string':
            return source;
          case !(source instanceof Object):
            return (require('fs')).readFileSync(source.schema, 'utf-8');
        }
      })());
    };
    this.set({
      map: {},
      importers: []
    });
    this.register = function(regex, func) {
      if (regex instanceof RegExp && func instanceof Function) {
        return (this.get('importers')).unshift({
          regex: regex,
          f: func
        });
      }
    };
    this.resolveFile = function(filename) {
      var ref;
      switch (false) {
        case !path.isAbsolute(filename):
          return filename;
        default:
          return path.resolve(path.dirname((ref = module.parent) != null ? ref.filename : void 0), filename);
      }
    };
    this.register(/.*\.yang$/, function(filename) {
      return this.compile({
        schema: this.resolveFile(filename)
      });
    });
    this.register(/.*/, function(filename) {
      return require(filename);
    });
    this["import"] = function(name) {
      var err, i, importer, len, m, ref, source;
      source = this.get("map." + name);
      ref = this.get('importers');
      for (i = 0, len = ref.length; i < len; i++) {
        importer = ref[i];
        if (!(source != null ? typeof source.match === "function" ? source.match(importer.regex) : void 0 : void 0)) {
          continue;
        }
        try {
          m = importer.f.call(this, source);
        } catch (_error) {
          err = _error;
          continue;
        }
        this.set("module/" + name, m);
        return m;
      }
      if (err == null) {
        err = "no matching 'source' found in the map";
      }
      console.log("WARN: unable to import module '" + name + "' due to " + err);
      return void 0;
    };
    this.merge('yang/augment', {
      resolver: function(arg, params) {
        var ref;
        if ((ref = this[arg]) != null) {
          if (typeof ref.extend === "function") {
            ref.extend(params);
          }
        }
        return null;
      }
    });
    this.merge('yang/import', {
      resolver: function(arg, params) {
        var mod, ref;
        mod = (ref = this.get("module/" + arg)) != null ? ref : this["import"](arg);
        if (params.prefix == null) {
          params.prefix = mod != null ? mod.prefix : void 0;
        }
        this.set("module/" + params.prefix, mod);
        return null;
      }
    });
    this.merge('yang/include', {
      resolver: function(arg, params) {
        var mod, ref;
        mod = this.get((ref = "submodule/" + arg) != null ? ref : this["import"](arg));
        this.extend(mod);
        return null;
      }
    });
    this.merge('yang/belongs-to', {
      resolver: function(arg, params) {
        this.set("module/" + params.prefix, this.get("module/" + arg));
        return null;
      }
    });
    this.merge('yang/refine', {
      resolver: function(arg, params) {
        var ref;
        if ((ref = this[arg]) != null) {
          if (typeof ref.extend === "function") {
            ref.extend(params);
          }
        }
        return null;
      }
    });
    this.merge('yang/uses', {
      resolver: function(arg, params) {
        return this.get("grouping/" + arg);
      }
    });
    this.merge('yang/feature', {
      meta: true
    });
    this.merge('yang/grouping', {
      meta: true
    });
    this.merge('yang/identity', {
      meta: true
    });
    this.merge('yang/revision', {
      meta: true
    });
    this.merge('yang/typedef', {
      meta: true
    });
    this.merge('yang/module', {
      "export": true
    });
    this.merge('yang/submodule', {
      "export": true
    });
    this.merge('yang/rpc', {
      "export": true
    });
    return this.merge('yang/notification', {
      "export": true
    });
  });

}).call(this);
