// Generated by CoffeeScript 1.9.1
(function() {
  var Meta, YangCompilerMixin,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Meta = require('./meta-class');

  YangCompilerMixin = (function(superClass) {
    var fs, path, readLocalFile;

    extend(YangCompilerMixin, superClass);

    function YangCompilerMixin() {
      return YangCompilerMixin.__super__.constructor.apply(this, arguments);
    }

    YangCompilerMixin.prototype.generate = function(input) {
      var actors, e, func, map, meta, name, obj, type;
      if (input instanceof Function) {
        input = input.call(this);
      }
      obj = (function() {
        switch (false) {
          case typeof input !== 'string':
            try {
              return JSON.parse(input);
            } catch (_error) {

            }
            break;
          case !(input instanceof Object):
            return input;
        }
      })();
      assert(obj instanceof Object, "cannot generate using invalid input data");
      if (Meta["instanceof"](obj)) {
        return obj;
      }
      meta = (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.merge(obj);

        return _Class;

      })(Meta);
      assert(typeof (meta.get('schema')) === 'string', "missing text schema to use for generate");
      actors = meta.extract('extensions', 'importers', 'procedures', 'hooks');
      for (type in actors) {
        map = actors[type];
        if (!(map instanceof Object)) {
          continue;
        }
        for (name in map) {
          func = map[name];
          if (func instanceof Function) {
            continue;
          }
          try {
            map[name] = eval("(" + func + ")");
          } catch (_error) {
            e = _error;
            delete map[name];
          }
          if (!(map[name] instanceof Function)) {
            delete map[name];
          }
        }
      }
      return this.fork(function() {
        this.set({
          map: meta.get('map'),
          version: meta.get('version')
        });
        this.set(actors);
        return this.compile(meta.get('schema'), this);
      });
    };

    path = require('path');

    fs = require('fs');

    readLocalFile = function(filename) {
      var file, ref;
      file = path.resolve(path.dirname((ref = module.parent) != null ? ref.filename : void 0), filename);
      return fs.readFileSync(file, 'utf-8');
    };

    YangCompilerMixin.importers = {
      '^meta:.*\.json$': function(input) {
        return readLocalFile(input.file);
      },
      '^schema:.*\.yang$': function(input) {
        input.schema = readLocalFile(input.file);
        return input;
      },
      '^module:': function(input) {
        return require(input.file);
      }
    };

    YangCompilerMixin.prototype["import"] = function(input) {
      var e, exists, importer, importers, k, output, payload, ref, ref1, ref2, regex, v;
      assert(input instanceof Object, "cannot call import without proper input object");
      exists = (function() {
        switch (false) {
          case !Meta["instanceof"](input):
            return input;
          case !Meta["instanceof"](input.source):
            return input.source;
          default:
            return this.resolve('module', input.name);
        }
      }).call(this);
      if (exists != null) {
        this.define('module', exists.get('name'), exists);
        return exists;
      }
      if (input.source == null) {
        input.source = this.get("map." + input.name);
      }
      assert(typeof input.source === 'string' && !!input.source, "unable to initiate import without a valid source parameter");
      if (input.file == null) {
        input.file = input.source.replace(/^.*:/, '');
      }
      importers = (ref = this.get('importers')) != null ? ref : {};
      ref1 = this.constructor.importers;
      for (k in ref1) {
        v = ref1[k];
        if (importers[k] == null) {
          importers[k] = v;
        }
      }
      this.set("importers", importers);
      ref2 = this.get('importers');
      for (regex in ref2) {
        importer = ref2[regex];
        if (!((new RegExp(regex)).test(input.source))) {
          continue;
        }
        try {
          payload = importer.call(this, input);
        } catch (_error) {
          e = _error;
          console.log(e);
          continue;
        }
        if (payload != null) {
          break;
        }
      }
      assert(payload != null, "unable to import requested module using '" + input.source + "'");
      output = this.generate(payload);
      if (output != null) {
        this.define('module', output.get('prefix'), output);
      }
      return output;
    };

    YangCompilerMixin.prototype["export"] = function(input) {
      var format, i, key, len, m, obj, ref, ref1, ref2, tosource;
      assert(input instanceof Object, "invalid input to export module");
      assert(typeof input.name === 'string' && !!input.name, "need to pass in 'name' of the module to export");
      format = (ref = input.format) != null ? ref : 'json';
      m = (function() {
        switch (false) {
          case !(Meta["instanceof"](input)):
            return input;
          default:
            return this.resolve('module', input.name);
        }
      }).call(this);
      assert(Meta["instanceof"](m), "unable to retrieve requested module " + input.name + " for export");
      tosource = require('tosource');
      obj = m.extract('name', 'schema', 'map', 'extensions', 'importers', 'exporters', 'procedures');
      ref1 = ['extensions', 'importers', 'procedures'];
      for (i = 0, len = ref1.length; i < len; i++) {
        key = ref1[i];
        if ((ref2 = obj[key]) != null) {
          ref2.toJSON = function() {
            var k, v;
            for (k in this) {
              v = this[k];
              if (k !== 'toJSON' && v instanceof Function) {
                this[k] = tosource(v);
              }
            }
            return this;
          };
        }
      }
      switch (format) {
        case 'json':
          return JSON.stringify(obj);
      }
    };

    return YangCompilerMixin;

  })(Meta);

  module.exports = YangCompilerMixin;

}).call(this);
