// Generated by CoffeeScript 1.9.1
(function() {
  var Meta, YangCompilerMixin,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Meta = (require('data-synth')).Meta;

  YangCompilerMixin = (function(superClass) {
    var fs, path, readLocalFile;

    extend(YangCompilerMixin, superClass);

    function YangCompilerMixin() {
      return YangCompilerMixin.__super__.constructor.apply(this, arguments);
    }

    YangCompilerMixin.prototype.generate = function(input) {
      var actors, e, func, map, meta, name, obj, type;
      if (input == null) {
        input = this;
      }
      if (input instanceof Function) {
        input = input.call(this);
      }
      obj = (function() {
        switch (false) {
          case typeof input !== 'string':
            try {
              return JSON.parse(input);
            } catch (_error) {

            }
            break;
          case !(input instanceof Object):
            return input;
        }
      })();
      assert(obj instanceof Object, "cannot generate using invalid input data");
      if (Meta["instanceof"](obj)) {
        return obj;
      }
      meta = ((function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        return _Class;

      })(Meta)).merge(obj);
      assert(typeof (meta.get('schema')) === 'string', "missing text schema to use for generate");
      actors = meta.extract('extensions', 'importers', 'procedures', 'hooks');
      for (type in actors) {
        map = actors[type];
        if (!(map instanceof Object)) {
          continue;
        }
        for (name in map) {
          func = map[name];
          if (func instanceof Function) {
            continue;
          }
          try {
            map[name] = eval("(" + func + ")");
          } catch (_error) {
            e = _error;
            delete map[name];
          }
          if (!(map[name] instanceof Function)) {
            delete map[name];
          }
        }
      }
      return this.fork(function() {
        this.set({
          map: meta.get('map'),
          version: meta.get('version')
        });
        this.set(actors);
        return this.compile(meta.get('schema'), this);
      });
    };

    path = require('path');

    fs = require('fs');

    readLocalFile = function(filename) {
      var file, ref;
      file = path.resolve(path.dirname((ref = module.parent) != null ? ref.filename : void 0), filename);
      return fs.readFileSync(file, 'utf-8');
    };

    YangCompilerMixin.importers = {
      '^meta:.*\.json$': function(input) {
        return readLocalFile(input.file);
      },
      '^schema:.*\.yang$': function(input) {
        input.schema = readLocalFile(input.file);
        return input;
      },
      '^module:': function(input) {
        return require(input.file);
      }
    };

    YangCompilerMixin.prototype["import"] = function(input) {
      var e, exists, hack, output, pkg;
      if (input == null) {
        input = {};
      }
      assert(input instanceof Object, "cannot call import without proper input object");
      exists = (function() {
        switch (false) {
          case !Meta["instanceof"](input):
            return input;
          default:
            return this.resolve('module', input.name);
        }
      }).call(this);
      if (exists != null) {
        this.define('module', exists.get('name'), exists);
        return exists;
      }
      try {
        console.log("INFO: importing '" + input.name + "'");
        pkg = require(input.name);
        hack = this.context;
        output = this.fork(function() {
          this.set(pkg.extract('dependencies', 'extensions', 'methods'));
          this.context = hack;
          return this.compile(pkg.get('schema.source'), this);
        });
      } catch (_error) {
        e = _error;
        console.log(e);
      }
      if (output != null) {
        this.define('module', input.name, output);
      }
      return output;
      output = this.generate(payload);
      if (output != null) {
        this.define('module', input.name, output);
      }
      return output;
    };

    YangCompilerMixin.prototype["export"] = function(input) {
      var format, i, key, len, m, obj, ref, ref1, ref2, tosource;
      assert(input instanceof Object, "invalid input to export module");
      assert(typeof input.name === 'string' && !!input.name, "need to pass in 'name' of the module to export");
      format = (ref = input.format) != null ? ref : 'json';
      m = (function() {
        switch (false) {
          case !(Meta["instanceof"](input)):
            return input;
          default:
            return this.resolve('module', input.name);
        }
      }).call(this);
      assert(Meta["instanceof"](m), "unable to retrieve requested module " + input.name + " for export");
      tosource = require('tosource');
      obj = m.extract('name', 'schema', 'map', 'extensions', 'importers', 'exporters', 'procedures');
      ref1 = ['extensions', 'importers', 'procedures'];
      for (i = 0, len = ref1.length; i < len; i++) {
        key = ref1[i];
        if ((ref2 = obj[key]) != null) {
          ref2.toJSON = function() {
            var k, v;
            for (k in this) {
              v = this[k];
              if (k !== 'toJSON' && v instanceof Function) {
                this[k] = tosource(v);
              }
            }
            return this;
          };
        }
      }
      switch (format) {
        case 'json':
          return JSON.stringify(obj);
      }
    };

    return YangCompilerMixin;

  })(Meta);

  module.exports = YangCompilerMixin;

}).call(this);
