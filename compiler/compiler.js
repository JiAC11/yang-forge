// Generated by CoffeeScript 1.9.1
(function() {
  var Meta, YangCompiler, assert,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  assert = require('assert');

  Meta = (require('data-synth')).Meta;

  YangCompiler = (function(superClass) {
    var id, normalize;

    extend(YangCompiler, superClass);

    function YangCompiler() {
      return YangCompiler.__super__.constructor.apply(this, arguments);
    }

    YangCompiler.mixin(require('./compiler-mixin'));

    YangCompiler.prototype.define = function(type, key, value) {
      var exists;
      exists = this.resolve(type, key);
      if (exists == null) {
        if (this.exports == null) {
          this.exports = {};
        }
        Meta.copy(this.exports, Meta.objectify(type + "." + key, value));
      }
      return void 0;
    };

    YangCompiler.prototype.resolve = function(type, key) {
      var i, prefix, ref, ref1, ref2, ref3;
      ref = key.split(':'), prefix = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), key = ref[i++];
      switch (false) {
        case !(prefix.length > 0):
          return (ref1 = this.resolve('module', prefix[0])) != null ? ref1.get(type + "." + key) : void 0;
        default:
          return (ref2 = this.exports) != null ? (ref3 = ref2[type]) != null ? ref3[key] : void 0 : void 0;
      }
    };

    normalize = function(obj) {
      return ([obj.prf, obj.kw].filter(function(e) {
        return (e != null) && !!e;
      })).join(':');
    };

    YangCompiler.prototype.parse = function(input, parser) {
      var e, params, stmt;
      if (parser == null) {
        parser = require('yang-parser');
      }
      try {
        if (typeof input === 'string') {
          input = parser.parse(input);
        }
      } catch (_error) {
        e = _error;
        console.log("ERR: [parse] failed to parse: " + input);
      }
      assert(input instanceof Object, "must pass in proper input to parse");
      params = ((function() {
        var i, len, ref, results;
        ref = input.substmts;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          stmt = ref[i];
          results.push(this.parse(stmt));
        }
        return results;
      }).call(this)).filter(function(e) {
        return e != null;
      }).reduce((function(a, b) {
        return Meta.copy(a, b);
      }), {});
      if (!(Object.keys(params).length > 0)) {
        params = void 0;
      }
      if (~input.arg.indexOf('.')) {
        return Meta.objectify("" + (normalize(input)), input.arg);
      } else {
        return Meta.objectify((normalize(input)) + "." + input.arg, params);
      }
    };

    YangCompiler.prototype.preprocess = function(input, context) {
      var arg, extractKeys, foundExtensions, key, params, val;
      if (context == null) {
        return this.fork((function() {
          return this.preprocess(input, this);
        }));
      }
      if (typeof input === 'string') {
        input = this.parse(input);
      }
      assert(input instanceof Object, "must pass in proper input to preprocess");
      extractKeys = function(x) {
        if (x instanceof Object) {
          return Object.keys(x);
        } else {
          return [x].filter(function(e) {
            return (e != null) && !!e;
          });
        }
      };
      console.log("INFO: [preprocess:" + this.id + "] scanning input for 'extension' and 'include' statements");
      if (context.exports == null) {
        context.exports = {};
      }
      foundExtensions = [];
      for (key in input) {
        val = input[key];
        if ((/^(sub)*module$/.test(key)) && val instanceof Object) {
          for (arg in val) {
            params = val[arg];
            if (!(params instanceof Object)) {
              continue;
            }
            if (params.extension != null) {
              params.extension = (extractKeys(params.extension)).map((function(_this) {
                return function(name) {
                  var extension;
                  foundExtensions.push(name);
                  extension = (function() {
                    switch (false) {
                      case !(params.extension instanceof Object):
                        return params.extension[name];
                      default:
                        return {};
                    }
                  })();
                  Meta.copy(extension, context.get("extensions." + name));
                  context.define('extension', name, extension);
                  return Meta.objectify(name, extension);
                };
              })(this)).reduce((function(a, b) {
                return Meta.copy(a, b);
              }), {});
            }
            if (params.include != null) {
              params.include = (extractKeys(params.include)).map((function(_this) {
                return function(name) {
                  var submod;
                  console.log("INFO: [preprocess:" + _this.id + ":include] submodule '" + name + "'");
                  submod = require(name);
                  console.log("INFO: [preprocess:" + _this.id + ":include] submodule '" + name + "' loaded: " + (submod != null));
                  Meta.copy(context, submod != null ? submod.extract('exports') : void 0);
                  return Meta.objectify(name, submod);
                };
              })(this)).reduce((function(a, b) {
                return Meta.copy(a, b);
              }), {});
            }
          }
        }
      }
      console.log("INFO: [preprocess:" + this.id + "] found extensions: '" + foundExtensions + "'");
      return input;
    };

    id = 0;

    YangCompiler.prototype.compile = function(input, context, scope) {
      var arg, ext, key, output, params, ref, ref1, ref2, res, stuff, val;
      if (input == null) {
        return;
      }
      if (context == null) {
        return this.fork(function() {
          var key, obj, output, value;
          this.id = id += 1;
          console.log("INFO: [compile] forked a new compile context " + this.id);
          obj = this.constructor.get('exports.extension');
          for (key in obj) {
            value = obj[key];
            Meta.copy(value, this.get("extensions." + key));
            this.define('extension', key, value);
          }
          console.log("INFO: [compile:" + this.id + "] job started with following extensions: " + (Object.keys(obj != null ? obj : {})));
          output = this.compile(input, this);
          if (output != null) {
            output.merge('exports', this.exports);
          }
          console.log("INFO: [compile:" + this.id + "] job finished");
          return output;
        });
      }
      if (input instanceof Function) {
        input = input.call(this);
      }
      if (typeof input === 'string') {
        input = this.preprocess(input, context);
      }
      assert(input instanceof Object, "must pass in proper input to compile");
      output = (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        return _Class;

      })(Meta);
      output.compiler = context;
      for (key in input) {
        val = input[key];
        if (!((scope == null) || key in scope)) {
          continue;
        }
        if (key === 'extension') {
          output.set(key, val);
          continue;
        }
        ext = this.resolve('extension', key);
        assert(ext instanceof Object, "ERROR: cannot compile statement with unknown extension '" + key + "'");
        if (val instanceof Object && (ext.argument != null)) {
          for (arg in val) {
            params = val[arg];
            stuff = (function() {
              switch (false) {
                case !(params instanceof Function):
                  return "{ [native code] }";
                case params == null:
                  return "{ " + (Object.keys(params)) + " }";
                default:
                  return "";
              }
            })();
            console.log("INFO: [compile:" + id + "] " + key + " " + arg + " " + stuff);
            res = (function() {
              switch (key) {
                case 'extension':
                case 'include':
                  return params;
                default:
                  return this.compile(params, context, ext);
              }
            }).call(this);
            output.set(key + "." + arg, params);
            if ((ref = ext.resolver) != null) {
              if (typeof ref.call === "function") {
                ref.call(output, arg, res);
              }
            }
          }
        } else {
          output.set(key, val);
          if (ext.argument != null) {
            console.log("INFO: [compile:" + id + "] " + key + " " + (val.slice(0, 50)) + "...");
            if ((ref1 = ext.resolver) != null) {
              if (typeof ref1.call === "function") {
                ref1.call(output, val, {});
              }
            }
          } else {
            console.log("INFO: [compile:" + id + "] " + key);
            if ((ref2 = ext.resolver) != null) {
              if (typeof ref2.call === "function") {
                ref2.call(output, key, val);
              }
            }
          }
        }
      }
      delete output.compiler;
      return output;
    };

    return YangCompiler;

  })(Meta);

  module.exports = YangCompiler;

}).call(this);
