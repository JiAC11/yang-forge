name: yangforge
description: YANG driven JS application builder
license: Apache-2.0
registry: https://yangforge.intercloud.net
keywords:
  - build
  - config
  - datastore
  - datamodel
  - forge
  - model
  - yang
  - opnfv
  - parse
  - restjson
  - restconf
  - rpc
  - translate
  - yang-json
  - yang-yaml
  - yfc

# schema - describes the data model of the application
schema: !yang/schema yangforge.yang

# config - contains the initial configuration of the application
config: !json yangforge.json

dependencies:
  yang-v1-extensions: !yaml/schema yang-v1-extensions.yaml
  ietf-yang-types: { schema: !yang/schema ietf-yang-types.yang }
  ietf-inet-types: { schema: !yang/schema ietf-inet-types.yang }
  iana-crypt-hash: { schema: !yang/schema iana-crypt-hash.yang }

extension:
  module: !yang/extension
    argument: name
    include: 0..n
    prefix: 0..1

  prefix: !yang/extension
    argument: value

  include: !yang/extension
    argument: module
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        m = @preprocess (@resolve 'dependencies', arg)
        @define 'extension', k, v for k, v of m.extension
        @define 'typedef', k, v for k, v of m.typedef
        ctx[k] = v for k, v of m.schema

feature:
  cli:      !yaml/schema features/cli.yaml
  express:  !yaml/schema features/express.yaml
  restjson: !yaml/schema features/restjson.yaml

route:
  /runtime/features: !coffee/function |
    (input, output, next) ->
      
rpc:
  build: !coffee/function |
    (input, output, done) ->
      @parent.import (input.get 'arguments')
      .then (apps) =>
        console.info app.info format: 'yaml' for app in apps
        done()
  
  config: !coffee/function |
    (input, output, done) ->

  info: !coffee/function |
    (input, output, done) ->
      target = (input.get 'arguments')[0]
      target ?= @parent
      @parent.import target
      .then (app) ->
        output.set app.info? (input.get 'options')
        done()
      .catch (err) -> done err

  schema: !coffee/function |
    (input, output, done) ->
      schema = (input.get 'arguments')[0]
      options = input.get 'options'

      schema = options.eval if options.eval?
      schema = (@parent.preprocess "schema: !yang/schema #{schema}").schema
      schema = @parent.render schema, options
      # TODO handle options.output to write to a file
      output.set schema
      done()

  infuse: !coffee/function |
    (input, output, done) ->
      targets = input.get 'targets'
      unless targets.length > 0
        output.set 'message', 'no operation since no target(s) were specified'
        done()
        return
      modules = for target in targets
        console.log "<infuse> absorbing a new source '#{target.source}' into running forge"
        m = @load target
        (@access 'runtime.modules').push m if m?
        m
      output.set 'message', 'request processed successfully'
      output.set 'modules', modules
      console.log "<infuse> completed"
      done()
      
  defuse: !coffee/function |
    (input, output, done) ->
      (@access 'runtime.modules').remove input.get 'targets'
      output.set 'message', 'OK'
      done()

  run: !coffee/function |
    (input, output, done) ->
      features = input.get 'options'
      if features.cli is true
        (@parent.resolve 'feature', 'cli').run this
        return done()

      for name, arg of features
        feature = @parent.resolve 'feature', name
        
      @invoke 'infuse', targets: (input.get 'arguments').map (e) -> source: e
      .then (res) =>
        modules = res.get 'modules'
        console.log "<run> starting up: " + modules.map (e) -> e.name
      .catch (e) -> done e

        

#     features = input.get 'options'
#     if features.cli is true
#       features = cli: on
#     else
#       @set 'features.cli', off
#       #process.argv = [] # hack for now...

#     console.log "forgery loading #{Object.keys(features)}..."
#     for feature, arg of features
#       continue unless arg? and arg

#       # @invoke 'enable', feature: feature, options: arg
#       #   .then (output) ->

#       try (@access 'features').push new (@load "features/#{feature}") null, this
#       catch e then console.warn "unable to load feature '#{feature}' due to #{e}"

#     # run passed in features
#     console.log "forgery firing up..."
#     for feature in @get 'features' when feature instanceof Forge.Meta
#       do (feature) =>
#         name = feature.meta 'name'
#         deps = for dep in (feature.meta 'needs') or []
#           console.log "forgery firing up '#{dep}' feature on-behalf of #{name}".green
#           (@get "features.#{dep}")?.run this, features[dep]
#         needs = deps.length
#         deps.unshift this
#         deps.push features[name]
#         console.log "forgery firing up '#{name}' feature with #{needs} dependents".green
#         feature.run.apply feature, deps

#     # console.log "forgery fired up!"
#     # console.warn @get 'features'
#     # console.warn @get 'modules'
#     next()

# @on 'list', (input, output, next) ->
#   options = input.get 'options'
#   modules = (@get 'modules').map (e) -> e.constructor.info options.verbose
#   unless options.verbose
#     console.info prettyjson.render modules
#     return next()
#   child = sys.exec 'npm list --json', timeout: 5000
#   child.stdout.on 'data', (data) ->
#     result = JSON.parse data
#     results = for mod in modules when result.name is mod.name
#       Forge.copy mod, result
#     console.info prettyjson.render results
#   child.stderr.on 'data', (data) -> console.warn data.red
#   child.on 'close', (code) -> next()

# @on 'enable', (input, output, next) ->
#   target = input.get 'feature'
#   feature = @access "features.#{target}"
#   unless feature?
#     feature = new (@load "features/#{target}") null, this
#     (@access 'features').push handler
#   handler.enable()
#   next()
