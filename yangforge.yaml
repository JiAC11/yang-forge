name: yangforge
description: YANG driven JS application builder
author: Peter K. Lee <peter@intercloud.net>
version: 0.10.5
license: Apache-2.0
homepage: http://github.com/saintkepha/yangforge
repository: git://github.com/saintkepha/yangforge.git
registry: https://yangforge.intercloud.net
keywords:
  - build
  - config
  - datastore
  - datamodel
  - forge
  - model
  - yang
  - opnfv
  - parse
  - restjson
  - restconf
  - rpc
  - translate
  - yang-json
  - yang-yaml
  - yfc

# schema - describes the data model of the application
schema: !yang yangforge.yang

# config - contains the initial configuration of the application
# it can be from a !json, !yaml or even directly defined here
config: !json yangforge.json

dependencies:
  yang-v1-extensions: !yaml yang-v1-extensions.yaml
  complex-types:      !yaml complex-types.yaml
  ietf-yang-types:    !yang ietf-yang-types.yang
  ietf-inet-types:    !yang ietf-inet-types.yang
  iana-crypt-hash:    !yang iana-crypt-hash.yang

extension:
  module: !yang/extension
    argument: name
    include: 0..n
    prefix: 0..1

  prefix: !yang/extension
    argument: value

  include: !yang/extension
    argument: module
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        m = @preprocess (@resolve 'dependencies', arg)
        @define 'extension', k, v for k, v of m.extension
        @define 'typedef', k, v for k, v of m.typedef
        ctx[k] = v for k, v of m.schema

feature:
  cli:      !yaml features/cli.yaml
  express:  !yaml features/express.yaml
  restjson: !yaml features/restjson.yaml

route:
  /runtime/features: !coffee/function |
    (input, output, next) ->
      
rpc:
  build: !coffee/function |
    (input, output, done) ->
      target = (input.get 'arguments')[0]
      options = input.get 'options'
      return done "must specify target input file to build" unless target?

      @parent.import target
      .then (app) =>
        result = app.constructor.toSource format: 'yaml'
        if options.gzip
          zlib = @parent.require 'zlib'
          #result = zlib.deflate result

        unless options.output?
          output.set result
          return done()

        fs = @parent.require 'fs'
        fs.writeFile options.output, result, 'utf8', (err) ->
          output.set "output saved to '#{options.output}'"
          if err? then done err else done()
      .catch (err) -> done err
  
  config: !coffee/function |
    (input, output, done) ->

  info: !coffee/function |
    (input, output, done) ->
      target = (input.get 'arguments')[0]
      target ?= @parent
      @parent.import target
      .then (app) ->
        output.set app.info? (input.get 'options')
        done()
      .catch (err) -> done err

  schema: !coffee/function |
    (input, output, done) ->
      options = input.get 'options'
      schema = (input.get 'arguments')[0]
      schema = options.eval if options.eval?
      result = switch
        when options.compile then @parent.compile "!yang #{schema}"
        when options.preprocess then (@parent.preprocess "!yang #{schema}").schema
        else @parent.parse "!yang #{schema}"
      result = (@parent.render result, options)
      unless options.output?
        output.set result
        return done()

      output.set "output saved to '#{options.output}'"
      fs = @parent.require 'fs'
      fs.writeFile options.output, result, 'utf8', (err) ->
        if err? then done err else done()

  infuse: !coffee/function |
    (input, output, done) ->
      targets = input.get 'targets'
      unless targets.length > 0
        output.set 'message', 'no operation since no target(s) were specified'
        return done()

      @parent.import (targets.map (e) -> e.source)
      .then (apps) =>
        models = []
        for app in apps
          for name, model of app.properties
            console.log "<infuse> absorbing a new model '#{name}' into running forge"
            @parent.attach name, model
            models.push name
        output.set 'message', 'request processed successfully'
        output.set 'modules', models
        console.log "<infuse> completed"
        done()
      .catch (err) -> done err
      
  defuse: !coffee/function |
    (input, output, done) ->
      for name in input.get 'names'
        @parent.detach name
      output.set 'message', 'OK'
      done()

  run: !coffee/function |
    (input, output, done) ->
      features = input.get 'options'
      if features.cli is true
        (@parent.resolve 'feature', 'cli').run this
        return done()

      console.log "forgery firing up..."
      for name, arg of features when arg? and arg isnt false
        console.log "#{name} with #{arg}"
        features[name] = (@parent.resolve 'feature', name)?.run? this, features
        
      @invoke 'infuse', targets: (input.get 'arguments').map (e) -> source: e
      .then (res) =>
        modules = res.get 'modules'
        output.set "<run> starting with: " + (modules)
        done()
      .catch (err) -> done err
