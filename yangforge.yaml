name: yangforge
description: YANG driven JS application builder
license: Apache-2.0
keywords:
  - build
  - config
  - datastore
  - datamodel
  - forge
  - model
  - yang
  - opnfv
  - parse
  - restjson
  - restconf
  - rpc
  - translate
  - yang-json
  - yang-yaml
  - yfc
schema: !yang/schema yangforge.yang
dependencies:
  yang-v1-extensions: !yaml/schema yang-v1-extensions.yaml
  ietf-yang-types: { schema: !yang/schema ietf-yang-types.yang }
  ietf-inet-types: { schema: !yang/schema ietf-inet-types.yang }
  iana-crypt-hash: { schema: !yang/schema iana-crypt-hash.yang }

extension:
  module: !yang/extension
    argument: name
    include: 0..n
    prefix: 0..1

  prefix: !yang/extension
    argument: value

  include: !yang/extension
    argument: module
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        m = @preprocess (@resolve 'dependencies', arg)
        @define 'extension', k, v for k, v of m.extension
        @define 'typedef', k, v for k, v of m.typedef
        ctx[k] = v for k, v of m.schema

feature:
  cli:      !yaml/schema features/cli.yaml
  express:  !yaml/schema features/express.yaml
  restjson: !yaml/schema features/restjson.yaml

route:
  /runtime/features: !coffee/function |
    (input, output, next) ->
      
rpc:
  build: !coffee/function |
    (input, output, done) ->
      modules = (@parent.import target for target in (input.get 'arguments'))
      console.info (@parent.render modules, noColor: true)
      done()
  
  config: !coffee/function |
    (input, output, done) ->

  info: !coffee/function |
    (input, output, done) ->
      targets = input.get 'arguments'
      unless targets.length > 0
        console.info @parent.render @parent.info this
        done()
        return

      @parent.import targets
      .catch (err) -> console.error err
      .then (apps) =>
        results = (@parent.info app for app in apps)
        console.info @parent.render results
        done()

  infuse: !coffee/function |
    (input, output, done) ->
      targets = input.get 'targets'
      unless targets.length > 0
        output.set 'message', 'no operation since no target(s) were specified'
        done()
        return
      modules = for target in targets
        console.log "<infuse> absorbing a new source '#{target.source}' into running forge"
        m = @load target
        (@access 'runtime.modules').push m if m?
        m
      output.set 'message', 'request processed successfully'
      output.set 'modules', modules
      console.log "<infuse> completed"
      done()
      
  defuse: !coffee/function |
    (input, output, done) ->
      (@access 'runtime.modules').remove input.get 'targets'
      output.set 'message', 'OK'
      done()

  run: !coffee/function |
    (input, output, done) ->
      features = input.get 'options'
      if features.cli is true
        (@parent.resolve 'feature', 'cli').run this
        return done()

      for name, arg of features
        feature = @parent.resolve 'feature', name
        
      @invoke 'infuse', targets: (input.get 'arguments').map (e) -> source: e
      .catch (e) -> done e
      .then (res) =>
        modules = res.get 'modules'
        console.log "<run> starting up: " + modules.map (e) -> e.name

        

#     features = input.get 'options'
#     if features.cli is true
#       features = cli: on
#     else
#       @set 'features.cli', off
#       #process.argv = [] # hack for now...

#     console.log "forgery loading #{Object.keys(features)}..."
#     for feature, arg of features
#       continue unless arg? and arg

#       # @invoke 'enable', feature: feature, options: arg
#       #   .then (output) ->

#       try (@access 'features').push new (@load "features/#{feature}") null, this
#       catch e then console.warn "unable to load feature '#{feature}' due to #{e}"

#     # run passed in features
#     console.log "forgery firing up..."
#     for feature in @get 'features' when feature instanceof Forge.Meta
#       do (feature) =>
#         name = feature.meta 'name'
#         deps = for dep in (feature.meta 'needs') or []
#           console.log "forgery firing up '#{dep}' feature on-behalf of #{name}".green
#           (@get "features.#{dep}")?.run this, features[dep]
#         needs = deps.length
#         deps.unshift this
#         deps.push features[name]
#         console.log "forgery firing up '#{name}' feature with #{needs} dependents".green
#         feature.run.apply feature, deps

#     # console.log "forgery fired up!"
#     # console.warn @get 'features'
#     # console.warn @get 'modules'
#     next()

  schema: !coffee/function |
    (input, output, next) ->
      schemas = input.get 'arguments'
      options = input.get 'options'

      if options.eval then schemas = [ options.eval ]
      else schemas = schemas.map (e) -> (fs.readFileSync e, 'utf-8')

      results = switch
        when options.compile
          # XXX - this is a bit of an ugly HACK... need to make this cleaner
          forgery = @constructor
          convert = (obj) ->
            yang = obj?.meta?.yang
            keys = Object.keys(forgery.get "exports.extension.#{yang}") if yang?
            meta = Forge.extract.apply obj.meta, keys if keys?
            o = {}
            for k, v of meta when v?
              switch v.meta?.yang
                when 'type'
                  type = convert v
                  delete type.type
                  if Object.keys(type).length > 0
                    o[v.meta.yang] = Forge.objectify v.meta.type, type
                  else
                    o[v.meta.yang] = v.meta.type
                else
                  o[k] = v
            (for k, v of obj when k isnt 'meta' and v?.meta?.yang?
              Forge.objectify "#{v.meta.yang}.#{k}", convert v
            ).reduce ((a, b) -> Forge.Meta.copy a, b), o
          (@compile schema for schema in schemas).map (x) -> convert x?.reduce()
        else
          @parse schema for schema in schemas

      results = results[0] if results.length is 1
      console.info switch
        when /^json$/i.test options.format then JSON.stringify results, null, 2
        else prettyjson.render results
      next()

# @on 'list', (input, output, next) ->
#   options = input.get 'options'
#   modules = (@get 'modules').map (e) -> e.constructor.info options.verbose
#   unless options.verbose
#     console.info prettyjson.render modules
#     return next()
#   child = sys.exec 'npm list --json', timeout: 5000
#   child.stdout.on 'data', (data) ->
#     result = JSON.parse data
#     results = for mod in modules when result.name is mod.name
#       Forge.copy mod, result
#     console.info prettyjson.render results
#   child.stderr.on 'data', (data) -> console.warn data.red
#   child.on 'close', (code) -> next()

# @on 'enable', (input, output, next) ->
#   target = input.get 'feature'
#   feature = @access "features.#{target}"
#   unless feature?
#     feature = new (@load "features/#{target}") null, this
#     (@access 'features').push handler
#   handler.enable()
#   next()
